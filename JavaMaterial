1. What‚Äôs the difference between JDK, JRE, and JVM?

‚¶Å	   JVM (Java Virtual Machine): Runs Java bytecode.
‚¶Å	   JRE (Java Runtime Environment): JVM + libraries for running Java programs.
‚¶Å	   JDK (Java Development Kit): JRE + development tools (compiler, debugger).

2. Why is Java considered platform-independent?

‚¶Å	   Java code is compiled into **bytecode**, which runs on any JVM regardless of the OS.

3. Difference between an abstract class and an interface?

   | Feature      | Abstract Class              | Interface                                        |
   | ------------ | --------------------------- | ------------------------------------------------ |
   | Inheritance  | Single inheritance          | Multiple inheritance                             |
   | Method types | Concrete + abstract methods | Only abstract (Java 7), default/static (Java 8+) |
   | Keyword      | `abstract`                  | `interface`                                      |

4. What‚Äôs the role of final, finally, and finalize in Java?

‚¶Å	   final: Prevents inheritance/modification.
‚¶Å	   finally: Used in exception handling to run cleanup code.
‚¶Å	   finalize(): Called by garbage collector before object is destroyed (deprecated in recent Java versions).

 1. final ‚Üí Can't Change
Use: Prevents modification (of variables, methods, or classes).

Variable	Value can‚Äôt be changed after initialization.
Method	Can‚Äôt be overridden in subclass.
Class	Can‚Äôt be inherited (subclassed).

 Example:
final int age = 25; // can't reassign age

final class Animal { } // can't extend this class

class Dog extends Animal { } // ERROR!

class Parent {
    final void show() {
        System.out.println("Hello");
    }
}

class Child extends Parent {
    void show() {} //  ERROR!
}

‚ÄúFinal = Fixed (can‚Äôt be changed)‚Äù

2. finally ‚Üí Always Executes
Use: A block that always runs after try-catch, even if there's an exception or return.

 Example:
try {
    int a = 5 / 0;
} catch (Exception e) {
    System.out.println("Error");
} finally {
    System.out.println("This will always run!");
}
Memory Tip:
‚ÄúFinally = I‚Äôll run no matter what!‚Äù
 3. finalize() ‚Üí Cleanup Before Destruction (Deprecated in newer Java versions)
Use: Called by the garbage collector before deleting the object to clean up resources.
 Example:
class MyClass {
    protected void finalize() {
        System.out.println("Object is being garbage collected");
    }
}
 Memory Tip:
‚ÄúFinalize = Last call before object dies (like a will)‚Äù

5. Stack vs. Heap memory: What‚Äôs the difference?

‚¶Å	   Stack: Stores method calls and local variables.
‚¶Å	   Heap: Stores objects and class instances.

 example:
public class Main {
    public static void main(String[] args) {
        int a = 10;
        Car c = new Car(); // Object creation
    }
}

class Car {
    int speed = 100;
}


 Memory Breakdown:
 int a = 10;
 is a primitive

Stored entirely in the Stack
 Car c = new Car();
c is a reference variable ‚Üí stored in Stack

new Car() creates a Car object ‚Üí stored in Heap

The speed inside Car (value 100) is also in Heap, because it belongs to the object.

So, Summary:
Element Memory Location
a = 10	Stack
c (reference)	Stack
new Car() (object)	Heap
speed = 100 inside Car	Heap

Key Rule to Remember:
‚¶Å	Primitives and references ‚Üí go to Stack
‚¶Å	Objects created with new ‚Üí go to Heap

| Feature           | Stack Memory                        | Heap Memory                       |
| ----------------- | ----------------------------------- | --------------------------------- |
| **Used For**      | Method calls, local variables       | Objects and instance variables    |
| **Memory Size**   | Small                               | Large                             |
| **Access Speed**  | Faster                              | Slower                            |
| **Lifetime**      | Until method ends                   | Until object is garbage collected |
| **Managed By**    | Java automatically                  | Java Garbage Collector            |
| **Thread Safety** | Yes (each thread has its own stack) | No (shared across threads)        |


6. Method overloading vs. method overriding?

‚¶Å	   Overloading: Same method name, different parameters (compile-time).
‚¶Å	   Overriding: Subclass redefines superclass method (runtime).

7. Difference between private and protected access modifiers?

‚¶Å	   private: Accessible only within the class.
‚¶Å	   protected: Accessible within the package and subclasses.

8. What‚Äôs constructor overloading in Java?

‚¶Å	   Defining multiple constructors in a class with different parameter lists.

9. Purpose of the super keyword in Java?

   Refers to the parent class and is used to:
‚¶Å	     Access parent class methods/variables.
‚¶Å	     Call parent class constructor.

10. What‚Äôs the purpose of static blocks in Java?

     Used to initialize static variables and run one-time code when class is loaded.

11. What are wrapper classes in Java?

‚¶Å	Wrapper classes convert primitive types (int, char, etc.) into objects (Integer, Character, etc.).
‚¶Å	Useful for working with collections and generics (like ArrayList) .

Primitive	Wrapper Class
‚¶Å	int    	Integer
‚¶Å	char	        Character
‚¶Å	boolean	Boolean
‚¶Å	byte  	Byte
‚¶Å	short	Short
‚¶Å	long	        Long
float	Float
‚¶Å	double	Double

int num = 10;
 Boxing (primitive ‚ûù object)
 Integer obj = num;

// Unboxing (object ‚ûù primitive)
int x = obj;

 Why is Integer an object but int is not?
üîπ 1. int is a primitive type
‚¶Å	It's not an object

‚¶Å	Stores only the value, like 5, 10, etc.

‚¶Å	No methods, no null, no OOP features

int a = 5; // just stores value 5

üîπ 2. Integer is a class (i.e., an object type)
‚¶Å	It's the wrapper for int

‚¶Å	You can use it like an object:

‚¶Å	Pass it to functions

‚¶Å	Store in collections

‚¶Å	Use methods like .compareTo(), .toString(), etc.

Integer b = 5; // Object form of int
System.out.println(b.toString()); // prints "5"


12. Difference between throw and throws?

Keyword	                   Purpose 	                    Used In	                Example
throw	  Actually throws an exception object	        Inside method	        throw new ArithmeticException();
throws	  Declares that method might throw exception	In method signature	void myMethod() throws IOException 


‚¶Å	Creates and throws an exception immediately.
‚¶Å	Only one exception object can be thrown at a time.
 Use throw when you want to manually create and throw an exception.

 For example:

‚¶Å	You want to stop the program if a condition is wrong.

‚¶Å	You want to give a custom error.

public class Test {
    public static void main(String[] args) {
        throw new ArithmeticException("Divide by zero");
    }
}
public void check() {
    int a = 10 / 0; // throws ArithmeticException automatically
}
This throws an unchecked exception, so no need to write throw or throws.

Method           	Used When...
throw new Exception()	You want to stop immediately due to a rule violation
if-else          	You want to handle it softly and show a message


üîπ throws ‚Äì Used to declare that a method may throw exceptions

Use throws when you call a method that might throw a checked exception ‚Äî but you don‚Äôt want to handle it right now.
when 
The file doesn‚Äôt exist?
‚¶Å	
‚¶Å	You don‚Äôt have permission?

public void readFile() throws IOException {
    FileReader file = new FileReader("test.txt");
}
This means: ‚ùó"I won‚Äôt handle the problem now ‚Äî someone else should."
public void readFile() {
    FileReader file = new FileReader("abc.txt"); // ‚ùå Compile error
}

Result: Compile-time error!
Because checked exceptions (like IOException) must be declared or handled.

Lets the caller know they must handle the exception.

Can declare multiple exceptions, like throws IOException, SQLException  public void readFile() throws IOException , SQLException{

readFile() is a helper function.
a library for math operations

Use Case	                   ¬†Use throws?	            Example
Utility/helper method	      ‚úÖ Yes	   File reading, DB connection
Library function	             ‚úÖ Yes	   Division, encryption, parsing
UI / App-specific code	      ‚ùå No	   Use try-catch directly
Business logic in activity    ‚ùå No	           Show Toast, alert, fallback


13. What is a try-catch block used for?

‚¶Å	To handle exceptions and prevent program crashes.

Syntax:
try {
    // code that may throw exception
} catch (Exception e) {
    // handle exception
}


14. Difference between checked and unchecked exceptions?
| Type              | Description                           | Example                                   |
|-------------------|---------------------------------------|------------------------                   |
| Checked Exception | Must be handled (compile-time)        | IOException, SQLException                 |
| Unchecked         | Occurs at runtime, not checked        | NullPointerException, ArithmeticException |



15. What is multithreading in Java?

‚¶Å	Ability to run multiple tasks (threads) concurrently to improve performance.
The ability of Java to execute two or more parts of a program at the same time, by running them in separate threads.
‚¶Å	Thread ‚Üí a lightweight unit of execution.
Multithreading ‚Üí many threads running concurrently.


class DownloadTask extends Thread {
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println("Downloading... " + i + "%");
            try { Thread.sleep(500); } catch (InterruptedException e) {}
        }
    }
}

class MusicTask extends Thread {
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println("Playing song... beat " + i);
            try { Thread.sleep(500); } catch (InterruptedException e) {}
        }
    }
}

public class MultiThreadDemo {
    public static void main(String[] args) {
        DownloadTask download = new DownloadTask();
        MusicTask music = new MusicTask();

        download.start(); // Start download thread
        music.start();    // Start music thread
    }
}

Android example
class MainActivity : AppCompatActivity() {

    private lateinit var mediaPlayer: MediaPlayer
    private val mainScope = MainScope() // For launching coroutines in this Activity

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // üéµ Start playing music (UI Thread)
        mediaPlayer = MediaPlayer.create(this, R.raw.song)
        mediaPlayer.start()

        // ‚¨á Start downloading file in background
        mainScope.launch(Dispatchers.IO) {
            downloadFile("https://example.com/song.mp3")

            // ‚úÖ Update UI after download
            withContext(Dispatchers.Main) {
                Toast.makeText(this@MainActivity, "Download complete!", Toast.LENGTH_SHORT).show()
            }
        }
    }
16. What is synchronization in Java?

‚¶Å	Ensures that only one thread accesses a resource at a time to prevent data inconsistency.
Without synchronized ‚Üí Multiple people writing in a notebook at the same time ‚Üí messy data.
‚¶Å	With synchronized ‚Üí Only one person writes at a time ‚Üí clean, correct data.

You have an Android chat app that:
‚¶Å	Has two background threads:
‚¶Å	One receives new messages from the server
‚¶Å	One saves them to a local database
‚¶Å	Both threads update the same ArrayList<Message> in memory

 Where This Is Useful in Android - chat aps , musixc apps, download manager, gams
‚¶Å	Updating shared data structures from multiple threads

‚¶Å	e.g., an in-memory cache, a list of download tasks

‚¶Å	Reading & writing to files or databases in background threads

‚¶Å	Working with LiveData/MutableState where multiple threads push updates

‚¶Å	Custom background workers in games, music apps, or real-time messaging

class ChatStorage {
    val messages = ArrayList<String>()

    @Synchronized
    fun addMessage(msg: String) {
        messages.add(msg) // Thread-safe now
    }
}

class MainActivity : AppCompatActivity() {
    private val storage = ChatStorage()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        Thread {
            repeat(1000) { storage.addMessage("From Thread 1: $it") }
        }.start()

        Thread {
            repeat(1000) { storage.addMessage("From Thread 2: $it") }
        }.start()
    }
}


17. Difference between process and thread?

| Aspect   | Process           | Thread                      |
|----------|-------------------|-----------------------------|
| Memory   | Own memory space  | Shares memory with process  |
| Overhead | Heavy             | Light                       |
| Execution| Independent       | Concurrent within a process |

Deep Understanding ‚Äî When to Use What
| You want to‚Ä¶                                                | Use **Process**                      ¬†| Use **Thread** |
| ----------------------------------------------------------- | -----------------------------------   | -------------- |
| Fully isolate tasks (crash in one shouldn‚Äôt kill the other) | ‚úÖ                                   | ‚ùå              |
| Run multiple things **inside the same app** and share data  | ‚ùå                                   | ‚úÖ              |
| Save memory                                                 | ‚ùå (each process has its own memory) | ‚úÖ              |
| Avoid UI freeze in Android                                  | ‚ùå (not needed)                      | ‚úÖ              |
| Run separate apps / system services                         | ‚úÖ                                   | ‚ùå              |


18. What are daemon threads?

Background threads that stop when the main thread ends (e.g., garbage collector).
Stops automatically when all non-daemon (user) threads finish.

If the main thread (the app's main worker) ends, daemon threads vanish automatically ‚Äî they don‚Äôt keep the program alive.


Why useful?
For background services that shouldn‚Äôt prevent the app from exiting:

‚¶Å	Garbage Collector

‚¶Å	Auto-saving

‚¶Å	Heartbeat pings

‚¶Å	Log writing

 Lock it in your head
‚¶Å	Daemon = Helper

‚¶Å	Stops with main

‚¶Å	No daemon ‚Üí app stays alive until thread ends

‚¶Å	Yes daemon ‚Üí app exits even if thread is still running

**A daemon thread is a helper thread that stops when the main thread ends, while a non-daemon thread keeps the app alive until it finishes.**
In Android, you don‚Äôt directly set daemon threads most of the time ‚Äî because the Android framework manages background threads for you using things like:

HandlerThread

Executors

WorkManager

AsyncTask (deprecated but still seen in older apps)

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        val thread = Thread {
            while (true) {
                Log.d("DaemonThread", "Uploading logs...")
                Thread.sleep(1000)
            }
        }

        thread.isDaemon = true // same as Java setDaemon(true)
        thread.start()

        Log.d("Main", "UI thread done with setup")
    }
}

What happens here?

‚¶Å	The UI thread (main) sets up the app.

‚¶Å	The daemon thread keeps uploading logs.

‚¶Å	If you close the activity and the main thread ends, the daemon thread also stops automatically.

Where you‚Äôd use daemon-like behavior in Android

‚¶Å	Log uploading in the background (non-essential work)

‚¶Å	Cache cleanup while the app is running

‚¶Å	Heartbeat pings to a server

‚¶Å	Preloading images in memory

These are helper tasks ‚Äî if the user leaves the app, we don‚Äôt care if they stop.

19. What is a deadlock?

A situation where two or more threads are waiting for each other forever, blocking progress.

‚¶Å	Person A has a spoon but needs a fork to eat.

‚¶Å	Person B has a fork but needs a spoon to eat.

‚¶Å	Both refuse to let go of what they have until they get the other utensil.
‚¶Å	‚Üí Result: Both wait forever, no one eats. 

You have multiple shared resources (files, database locks, network sockets).

‚¶Å	Different threads acquire them in different orders.

‚¶Å	Example:

‚¶Å	Thread 1 locks Resource A ‚Üí waits for Resource B.

Thread 2 locks Resource B ‚Üí waits for Resource A.

Demo deadlock

public class MainActivity extends AppCompatActivity {

    private final Object mediaPlayerLock = new Object();
    private final Object networkLock = new Object();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        Thread threadA = new Thread(() -> {
            synchronized (mediaPlayerLock) {
                Log.d("DEADLOCK", "Thread A: Locked MediaPlayer");

                try { Thread.sleep(100); } catch (InterruptedException ignored) {}

                synchronized (networkLock) {
                    Log.d("DEADLOCK", "Thread A: Locked Network");
                }
            }
        });

        Thread threadB = new Thread(() -> {
            synchronized (networkLock) {
                Log.d("DEADLOCK", "Thread B: Locked Network");

                try { Thread.sleep(100); } catch (InterruptedException ignored) {}

                synchronized (mediaPlayerLock) {
                    Log.d("DEADLOCK", "Thread B: Locked MediaPlayer");
                }
            }
        });

        threadA.start();
        threadB.start();
    }
}

fixed version

public class MainActivity extends AppCompatActivity {

    private final Object mediaPlayerLock = new Object();
    private final Object networkLock = new Object();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        Thread threadA = new Thread(() -> {
            synchronized (mediaPlayerLock) {
                Log.d("FIXED", "Thread A: Locked MediaPlayer");

                try { Thread.sleep(100); } catch (InterruptedException ignored) {}

                synchronized (networkLock) {
                    Log.d("FIXED", "Thread A: Locked Network");
                }
            }
        });

        Thread threadB = new Thread(() -> {
            synchronized (mediaPlayerLock) { // üîπ Lock order matches Thread A
                Log.d("FIXED", "Thread B: Locked MediaPlayer");

                try { Thread.sleep(100); } catch (InterruptedException ignored) {}

                synchronized (networkLock) {
                    Log.d("FIXED", "Thread B: Locked Network");
                }
            }
        });

        threadA.start();
        threadB.start();
    }
}

without lambda 
Thread threadA = new Thread(new Runnable() {
    @Override
    public void run() {
}}
with lambda
Thread threadA = new Thread(() -> {
    // code
});

20. What is the purpose of the transient keyword?

Used to skip a field during serialization.
‚Äúüö´ Don‚Äôt save this field when you serialize the object.‚Äù

Why this is important in Android:

Security: API keys, passwords, session tokens aren‚Äôt stored in plain files.

Performance: Skip heavy non-serializable objects (e.g., Bitmaps, MediaPlayers).

üí° Why use transient here?

You don‚Äôt need to save Context (you can get it again from the Android framework).

Prevents crashes when serializing non-serializable objects.

Keeps saved files smaller by excluding unnecessary data.


import java.io.Serializable;
import android.content.Context;

public class MyData implements Serializable {
    String name;
    transient Context context; // ‚úÖ Ignored during serialization

    public MyData(String name, Context context) {
        this.name = name;
        this.context = context;
    }
}
Now, when serializing, context is skipped ‚Äî so no NotSerializableException.


If you try to save this object with ObjectOutputStream, the app crashes because Context cannot be serialized.


